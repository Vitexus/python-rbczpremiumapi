# coding: utf-8

{{>partial_header}}

{{#models}}
{{#model}}
from datetime import date, datetime
from typing import Dict, List, Optional, Union
from pydantic import BaseModel, StrictBool, StrictFloat, StrictInt, StrictStr, validator

{{#description}}
"""
{{.}}
"""
{{/description}}

class {{classname}}(BaseModel):
{{#description}}
    """
    {{.}}
    """
{{/description}}

{{#vars}}
{{#description}}
    # {{description}}
{{/description}}
    {{name}}: {{#required}}{{dataType}}{{/required}}{{^required}}Optional[{{dataType}}] = None{{/required}}{{#hasMore}}{{/hasMore}}
{{/vars}}

{{#hasValidation}}
{{#vars}}
{{#hasValidation}}
    @validator('{{name}}')
    def {{name}}_validate_regular_expression(cls, value):
        """Validates the regular expression"""
{{#pattern}}
        if not re.match(r"{{.}}", value):
            raise ValueError("Invalid value for `{{name}}`, must be a valid regular expression")
{{/pattern}}
{{#minimum}}
        if value is not None and value < {{.}}:
            raise ValueError("Invalid value for `{{name}}`, must be a value greater than or equal to `{{.}}`")
{{/minimum}}
{{#maximum}}
        if value is not None and value > {{.}}:
            raise ValueError("Invalid value for `{{name}}`, must be a value less than or equal to `{{.}}`")
{{/maximum}}
{{#minLength}}
        if value is not None and len(value) < {{.}}:
            raise ValueError("Invalid value for `{{name}}`, length must be greater than or equal to `{{.}}`")
{{/minLength}}
{{#maxLength}}
        if value is not None and len(value) > {{.}}:
            raise ValueError("Invalid value for `{{name}}`, length must be less than or equal to `{{.}}`")
{{/maxLength}}
        return value
{{/hasValidation}}
{{/vars}}
{{/hasValidation}}

{{/model}}
{{/models}}